CREATE OR REPLACE FUNCTION pg_catalog.lpad(bigint, integer, varchar)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
SELECT pg_catalog.lpad($1::text, $2, $3::text)
$function$


 create or replace procedure get_actural_index_drop()
language plpgsql
as $$
  declare 
    cursor_sql record;
    i int:=0;
begin
for cursor_sql in(
SELECT
    n.nspname AS schemaname,
    i.relname AS indexname  
FROM pg_index x
    JOIN pg_class c ON c.oid = x.indrelid
    JOIN pg_class i ON i.oid = x.indexrelid
    LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
    LEFT JOIN pg_tablespace t ON t.oid = i.reltablespace
WHERE (c.relkind = ANY (ARRAY['r'::"char", 'm'::"char"])) AND i.relkind = 'i'::"char" and n.nspname='infodba'
) loop
 execute 'drop index '||cursor_sql.schemaname||'.'||cursor_sql.indexname||'';
 i=i+1;
 raise notice '%',i;
 commit;
end loop;
end;
$$;
-----------------------------------------------------------------

CREATE OR REPLACE FUNCTION count_records_dynamically() RETURNS VOID AS $$
DECLARE
  cursor_sql RECORD;
  table_count INTEGER;
BEGIN
  FOR cursor_sql IN
    SELECT tablename FROM pg_tables WHERE schemaname = 'public' -- 可以更改为特定的模式或删除该过滤条件以包括所有模式的表
  LOOP
    EXECUTE 'SELECT COUNT(*) FROM ' || cursor_sql.tablename INTO table_count;
    INSERT INTO tmp_table_count (table_name, record_count) VALUES (cursor_sql.tablename, table_count);
  END LOOP;
END;
$$ LANGUAGE plpgsql;


create table TMP_GET_ACTURAL_TABLE_COUNT(table_name varchar(50),table_cnt int);
select * from TMP_GET_ACTURAL_TABLE_COUNT;

CREATE OR REPLACE PROCEDURE GET_ACTURAL_TABLE_COUNT(isrun integer) AUTHID CURRENT_USER IS 
  cursor_sql SYS_REFCURSOR;
  record_count number;
BEGIN
  FOR cursor_sql IN (SELECT table_name FROM user_tables ) LOOP
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || cursor_sql.table_name INTO record_count;
    INSERT INTO TMP_GET_ACTURAL_TABLE_COUNT (table_name, table_cnt) VALUES (cursor_sql.table_name, record_count);
	  DBMS_OUTPUT.PUT_LINE('table '||cursor_sql.table_name || ':' ||record_count);
      COMMIT;
  END LOOP;
  COMMIT;
END;
--------------------------
CREATE OR REPLACE PROCEDURE compare_all_table_columns(
  
)
AS $$
DECLARE
  table_name VARCHAR;
  column_count1 INTEGER;
  column_count2 INTEGER;
  column_name1 VARCHAR;
  column_name2 VARCHAR;
BEGIN
  -- 获取 schema1 中所有表的信息
  FOR table_name IN (SELECT table_name FROM information_schema.tables WHERE table_schema = schema1) LOOP
    -- 获取表1的字段数量和字段名
    EXECUTE format('SELECT COUNT(*), column_name FROM information_schema.columns WHERE table_schema = %L AND table_name = %L GROUP BY column_name', schema1, table_name) INTO column_count1, column_name1;

    -- 获取表2的字段数量和字段名
    EXECUTE format('SELECT COUNT(*), column_name FROM information_schema.columns WHERE table_schema = %L AND table_name = %L GROUP BY column_name', schema2, table_name) INTO column_count2, column_name2;

    -- 比较字段数量
    IF column_count1 > column_count2 THEN
      RAISE NOTICE '表 % 格式字段数量不一致', table_name;
      CONTINUE;
    END IF;
	
	
	---获取表名、字段名等信息。插入表中

   
  END LOOP;
  ---添加列的信息
END;
$$ LANGUAGE plpgsql;


select * from dblink('dbname=tc_test','select table_name,column_name from information_schema.columns where table_name not in(select table_name from information_schema.views)') as t(table_name varchar(100),
column_name varchar(30))
except 
select * from dblink('dbname=tc','select table_name,column_name from information_schema.columns where table_name not in(select table_name from information_schema.views)') as t(table_name varchar(100),column_name varchar(30)); 

CREATE TABLE col(
  "table_catalog" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "table_schema" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "table_name" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "column_name" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "ordinal_position" "information_schema"."cardinal_number",
  "column_default" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "is_nullable" "information_schema"."yes_or_no" COLLATE "pg_catalog"."C",
  "data_type" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "character_maximum_length" "information_schema"."cardinal_number",
  "character_octet_length" "information_schema"."cardinal_number",
  "numeric_precision" "information_schema"."cardinal_number",
  "numeric_precision_radix" "information_schema"."cardinal_number",
  "numeric_scale" "information_schema"."cardinal_number",
  "datetime_precision" "information_schema"."cardinal_number",
  "interval_type" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "interval_precision" "information_schema"."cardinal_number",
  "character_set_catalog" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "character_set_schema" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "character_set_name" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "collation_catalog" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "collation_schema" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "collation_name" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "domain_catalog" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "domain_schema" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "domain_name" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "udt_catalog" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "udt_schema" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "udt_name" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "scope_catalog" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "scope_schema" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "scope_name" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "maximum_cardinality" "information_schema"."cardinal_number",
  "dtd_identifier" "information_schema"."sql_identifier" COLLATE "pg_catalog"."C",
  "is_self_referencing" "information_schema"."yes_or_no" COLLATE "pg_catalog"."C",
  "is_identity" "information_schema"."yes_or_no" COLLATE "pg_catalog"."C",
  "identity_generation" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "identity_start" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "identity_increment" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "identity_maximum" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "identity_minimum" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "identity_cycle" "information_schema"."yes_or_no" COLLATE "pg_catalog"."C",
  "is_generated" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "generation_expression" "information_schema"."character_data" COLLATE "pg_catalog"."C",
  "is_updatable" "information_schema"."yes_or_no" COLLATE "pg_catalog"."C",
  add_col varchar(200)
)
;


CREATE OR REPLACE PROCEDURE GET_TABLE_column(isrun integer) 
language plpgsql
AS $$
declare  
    cursor_sql record;
begin
    for cursor_sql in(	  
    select * from dblink('dbname=tc_test','select table_name,column_name from information_schema.columns where table_name not in(select table_name from information_schema.views)') as t(table_name varchar(100),
column_name varchar(30))
except 
select * from dblink('dbname=tc','select table_name,column_name from information_schema.columns where table_name not in(select table_name from information_schema.views)') as t(table_name varchar(100),column_name varchar(30))
	) loop
	      execute null;
		  insert into col
		   select * from dblink('dbname=tc_test','select * where table_name not in(select table_name from information_schema.views)' and table_name=cursor_sql.table_name and table_column=cursor_sql.table_column) as t(table_name varchar(100));
		  end loop;
end;
$$;

GET_TABLE_column(1);

CREATE OR REPLACE FUNCTION login_hook.login() RETURNS VOID LANGUAGE PLPGSQL AS $$
DECLARE
ex_state TEXT;
ex_message TEXT;
ex_detail TEXT;
ex_hint TEXT;
ex_context TEXT;
BEGIN
LOAD '$libdir/plugins/pgtt';
END
$$;
GRANT EXECUTE ON FUNCTION login_hook.login() TO PUBLIC;

SELECT t_02.pvalu_0, t_02.pvalu_0,t_02.pvalc_0 FROM PREVISIONANCHOR t_01 , PREVISIONS t_02 WHERE ( ( t_02.puid IN  ( SELECT t_03.rrev_chain_anchoru FROM PDATASET t_03,PString1TT WHERE t_03.puid = PString1TT.astring  AND (t_03.arev_category IN (48,40)) ) AND ( t_02.pseq = 0 ) ) AND ( t_01.puid = t_02.puid ) ) ;

