-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.2
-- Copyright 2000-2023 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=100.80.38.27;SERVICE_NAME=mespmmuat_srv;port=1521

SET client_encoding TO 'UTF8';

SET search_path = public;
DROP TRIGGER IF EXISTS fast_sync_add_trigger ON ppom_object CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_fast_sync_add_trigger() RETURNS trigger AS $BODY$
declare gmtDate timestamp(0);BEGIN                                                  select (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') into STRICT gmtDate;                                                  insert into scratch_table values (COALESCE(newRow.aoid, newRow.puid), gmtDate, '8');                                                  RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_fast_sync_add_trigger() FROM PUBLIC;

CREATE TRIGGER fast_sync_add_trigger
	BEFORE INSERT ON ppom_object FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_fast_sync_add_trigger();

DROP TRIGGER IF EXISTS fast_sync_delete_trigger ON ppom_object CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_fast_sync_delete_trigger() RETURNS trigger AS $BODY$
declare gmtDate timestamp(0);BEGIN                                                     select (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') into STRICT gmtDate;                                                     insert into scratch_table values (COALESCE(oldRow.aoid, oldRow.puid), gmtDate, '9');                                                     RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_fast_sync_delete_trigger() FROM PUBLIC;

CREATE TRIGGER fast_sync_delete_trigger
	AFTER DELETE ON ppom_object FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_fast_sync_delete_trigger();

DROP TRIGGER IF EXISTS insert_object_uid ON ppom_stub CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_insert_object_uid() RETURNS trigger AS $BODY$
compound trigger
    type typ is table of  PPOM_STUB%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE saveLocks
   AS   v_updates       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_updates
   MERGE INTO  POM_LOCK_KEYS lk USING( SELECT recs[v_count].pobject_uid AS puid  ) src ON ( src.puid = lk.puid ) WHEN NOT MATCHED THEN
   INSERT( lk.puid ) VALUES ( src.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].pobject_uid := NEW.pobject_uid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   saveLocks();
   END AFTER STATEMENT;
   RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_insert_object_uid() FROM PUBLIC;

CREATE TRIGGER insert_object_uid
	COMPOUND INSERT ON ppom_stub FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_insert_object_uid();

DROP TRIGGER IF EXISTS locking_delete_1 ON ppom_object CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PPOM_OBJECT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid ) AND NOT EXISTS ( SELECT COUNT(pt.aoid),pt.aoid FROM PPOM_OBJECT pt WHERE pt.aoid = POM_LOCK_KEYS.puid GROUP BY pt.aoid HAVING COUNT(pt.aoid) >1);
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.aoid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1() FROM PUBLIC;

CREATE TRIGGER locking_delete_1
	COMPOUND DELETE ON ppom_object FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1();

DROP TRIGGER IF EXISTS locking_delete_1039 ON pfnd0fileaccessaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1039() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0FILEACCESSAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1039() FROM PUBLIC;

CREATE TRIGGER locking_delete_1039
	COMPOUND DELETE ON pfnd0fileaccessaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1039();

DROP TRIGGER IF EXISTS locking_delete_1319 ON pcae0simprocessjobdetails CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1319() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0SIMPROCESSJOBDETAILS%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1319() FROM PUBLIC;

CREATE TRIGGER locking_delete_1319
	COMPOUND DELETE ON pcae0simprocessjobdetails FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1319();

DROP TRIGGER IF EXISTS locking_delete_1322 ON pcae0toolaccesscontrol CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1322() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLACCESSCONTROL%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1322() FROM PUBLIC;

CREATE TRIGGER locking_delete_1322
	COMPOUND DELETE ON pcae0toolaccesscontrol FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1322();

DROP TRIGGER IF EXISTS locking_delete_1323 ON pcae0toolenvvariabledetails CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1323() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLENVVARIABLEDETAILS%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1323() FROM PUBLIC;

CREATE TRIGGER locking_delete_1323
	COMPOUND DELETE ON pcae0toolenvvariabledetails FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1323();

DROP TRIGGER IF EXISTS locking_delete_1324 ON pcae0toolenvvariables CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1324() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLENVVARIABLES%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1324() FROM PUBLIC;

CREATE TRIGGER locking_delete_1324
	COMPOUND DELETE ON pcae0toolenvvariables FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1324();

DROP TRIGGER IF EXISTS locking_delete_1325 ON pcae0toolfeedbackconfig CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1325() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLFEEDBACKCONFIG%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1325() FROM PUBLIC;

CREATE TRIGGER locking_delete_1325
	COMPOUND DELETE ON pcae0toolfeedbackconfig FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1325();

DROP TRIGGER IF EXISTS locking_delete_1326 ON pcae0toolgeneralconfig CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1326() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLGENERALCONFIG%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1326() FROM PUBLIC;

CREATE TRIGGER locking_delete_1326
	COMPOUND DELETE ON pcae0toolgeneralconfig FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1326();

DROP TRIGGER IF EXISTS locking_delete_1327 ON pcae0toolinputparamdetails CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1327() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLINPUTPARAMDETAILS%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1327() FROM PUBLIC;

CREATE TRIGGER locking_delete_1327
	COMPOUND DELETE ON pcae0toolinputparamdetails FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1327();

DROP TRIGGER IF EXISTS locking_delete_1329 ON pcae0toollaunchparameters CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1329() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLLAUNCHPARAMETERS%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1329() FROM PUBLIC;

CREATE TRIGGER locking_delete_1329
	COMPOUND DELETE ON pcae0toollaunchparameters FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1329();

DROP TRIGGER IF EXISTS locking_delete_1331 ON pcae0tooloutputobjectdetails CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1331() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLOUTPUTOBJECTDETAILS%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1331() FROM PUBLIC;

CREATE TRIGGER locking_delete_1331
	COMPOUND DELETE ON pcae0tooloutputobjectdetails FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1331();

DROP TRIGGER IF EXISTS locking_delete_1333 ON pcae0toolruletpdetails CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1333() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLRULETPDETAILS%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1333() FROM PUBLIC;

CREATE TRIGGER locking_delete_1333
	COMPOUND DELETE ON pcae0toolruletpdetails FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1333();

DROP TRIGGER IF EXISTS locking_delete_1603 ON pcae0toolrule CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1603() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLRULE%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1603() FROM PUBLIC;

CREATE TRIGGER locking_delete_1603
	COMPOUND DELETE ON pcae0toolrule FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1603();

DROP TRIGGER IF EXISTS locking_delete_162 ON pfnd0contextspecificid CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_162() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0CONTEXTSPECIFICID%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_162() FROM PUBLIC;

CREATE TRIGGER locking_delete_162
	COMPOUND DELETE ON pfnd0contextspecificid FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_162();

DROP TRIGGER IF EXISTS locking_delete_1641 ON pcae0toolattributeconfig CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1641() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLATTRIBUTECONFIG%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1641() FROM PUBLIC;

CREATE TRIGGER locking_delete_1641
	COMPOUND DELETE ON pcae0toolattributeconfig FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1641();

DROP TRIGGER IF EXISTS locking_delete_1642 ON pcae0toolinputconfig CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1642() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLINPUTCONFIG%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1642() FROM PUBLIC;

CREATE TRIGGER locking_delete_1642
	COMPOUND DELETE ON pcae0toolinputconfig FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1642();

DROP TRIGGER IF EXISTS locking_delete_1643 ON pcae0tooloutputconfig CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1643() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLOUTPUTCONFIG%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1643() FROM PUBLIC;

CREATE TRIGGER locking_delete_1643
	COMPOUND DELETE ON pcae0tooloutputconfig FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1643();

DROP TRIGGER IF EXISTS locking_delete_170 ON pfnd0digitalsignatureaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_170() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0DIGITALSIGNATUREAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_170() FROM PUBLIC;

CREATE TRIGGER locking_delete_170
	COMPOUND DELETE ON pfnd0digitalsignatureaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_170();

DROP TRIGGER IF EXISTS locking_delete_176 ON pfnd0generalaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_176() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0GENERALAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_176() FROM PUBLIC;

CREATE TRIGGER locking_delete_176
	COMPOUND DELETE ON pfnd0generalaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_176();

DROP TRIGGER IF EXISTS locking_delete_185 ON pfnd0licensechangeaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_185() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0LICENSECHANGEAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_185() FROM PUBLIC;

CREATE TRIGGER locking_delete_185
	COMPOUND DELETE ON pfnd0licensechangeaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_185();

DROP TRIGGER IF EXISTS locking_delete_186 ON pfnd0licenseexportaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_186() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0LICENSEEXPORTAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_186() FROM PUBLIC;

CREATE TRIGGER locking_delete_186
	COMPOUND DELETE ON pfnd0licenseexportaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_186();

DROP TRIGGER IF EXISTS locking_delete_187 ON pfnd0licenselogintimes CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_187() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0LICENSELOGINTIMES%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_187() FROM PUBLIC;

CREATE TRIGGER locking_delete_187
	COMPOUND DELETE ON pfnd0licenselogintimes FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_187();

DROP TRIGGER IF EXISTS locking_delete_191 ON pfnd0loginlicenseinfo CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_191() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0LOGINLICENSEINFO%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_191() FROM PUBLIC;

CREATE TRIGGER locking_delete_191
	COMPOUND DELETE ON pfnd0loginlicenseinfo FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_191();

DROP TRIGGER IF EXISTS locking_delete_193 ON pfnd0message_0 CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_193() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0MESSAGE_0%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_193() FROM PUBLIC;

CREATE TRIGGER locking_delete_193
	COMPOUND DELETE ON pfnd0message_0 FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_193();

DROP TRIGGER IF EXISTS locking_delete_1938 ON pcae0tooloptionalinputdetail CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_1938() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PCAE0TOOLOPTIONALINPUTDETAIL%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_1938() FROM PUBLIC;

CREATE TRIGGER locking_delete_1938
	COMPOUND DELETE ON pcae0tooloptionalinputdetail FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_1938();

DROP TRIGGER IF EXISTS locking_delete_199 ON pfnd0organizationaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_199() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0ORGANIZATIONAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_199() FROM PUBLIC;

CREATE TRIGGER locking_delete_199
	COMPOUND DELETE ON pfnd0organizationaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_199();

DROP TRIGGER IF EXISTS locking_delete_205 ON pfnd0scheduleaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_205() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0SCHEDULEAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_205() FROM PUBLIC;

CREATE TRIGGER locking_delete_205
	COMPOUND DELETE ON pfnd0scheduleaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_205();

DROP TRIGGER IF EXISTS locking_delete_206 ON pfnd0secondaryaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_206() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0SECONDARYAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_206() FROM PUBLIC;

CREATE TRIGGER locking_delete_206
	COMPOUND DELETE ON pfnd0secondaryaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_206();

DROP TRIGGER IF EXISTS locking_delete_207 ON pfnd0securityaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_207() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0SECURITYAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_207() FROM PUBLIC;

CREATE TRIGGER locking_delete_207
	COMPOUND DELETE ON pfnd0securityaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_207();

DROP TRIGGER IF EXISTS locking_delete_209 ON pfnd0structureaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_209() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0STRUCTUREAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_209() FROM PUBLIC;

CREATE TRIGGER locking_delete_209
	COMPOUND DELETE ON pfnd0structureaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_209();

DROP TRIGGER IF EXISTS locking_delete_217 ON pfnd0workflowaudit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_217() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0WORKFLOWAUDIT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_217() FROM PUBLIC;

CREATE TRIGGER locking_delete_217
	COMPOUND DELETE ON pfnd0workflowaudit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_217();

DROP TRIGGER IF EXISTS locking_delete_2260 ON pfnd0preferencecategory CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2260() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0PREFERENCECATEGORY%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2260() FROM PUBLIC;

CREATE TRIGGER locking_delete_2260
	COMPOUND DELETE ON pfnd0preferencecategory FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2260();

DROP TRIGGER IF EXISTS locking_delete_2261 ON pfnd0preferencedefinition CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2261() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0PREFERENCEDEFINITION%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2261() FROM PUBLIC;

CREATE TRIGGER locking_delete_2261
	COMPOUND DELETE ON pfnd0preferencedefinition FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2261();

DROP TRIGGER IF EXISTS locking_delete_2262 ON pfnd0preferencevalue CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2262() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0PREFERENCEVALUE%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2262() FROM PUBLIC;

CREATE TRIGGER locking_delete_2262
	COMPOUND DELETE ON pfnd0preferencevalue FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2262();

DROP TRIGGER IF EXISTS locking_delete_2263 ON pfnd0attrdescriptioninfo CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2263() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0ATTRDESCRIPTIONINFO%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2263() FROM PUBLIC;

CREATE TRIGGER locking_delete_2263
	COMPOUND DELETE ON pfnd0attrdescriptioninfo FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2263();

DROP TRIGGER IF EXISTS locking_delete_2264 ON pawp0favoritesavedsearch CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2264() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PAWP0FAVORITESAVEDSEARCH%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2264() FROM PUBLIC;

CREATE TRIGGER locking_delete_2264
	COMPOUND DELETE ON pawp0favoritesavedsearch FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2264();

DROP TRIGGER IF EXISTS locking_delete_2311 ON pfnd0directedlink CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2311() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0DIRECTEDLINK%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2311() FROM PUBLIC;

CREATE TRIGGER locking_delete_2311
	COMPOUND DELETE ON pfnd0directedlink FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2311();

DROP TRIGGER IF EXISTS locking_delete_2319 ON pfnd0oarelement CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2319() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0OARELEMENT%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2319() FROM PUBLIC;

CREATE TRIGGER locking_delete_2319
	COMPOUND DELETE ON pfnd0oarelement FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2319();

DROP TRIGGER IF EXISTS locking_delete_2320 ON pfnd0oarfunction CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2320() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0OARFUNCTION%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2320() FROM PUBLIC;

CREATE TRIGGER locking_delete_2320
	COMPOUND DELETE ON pfnd0oarfunction FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2320();

DROP TRIGGER IF EXISTS locking_delete_2321 ON pfnd0oaroperation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2321() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0OAROPERATION%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2321() FROM PUBLIC;

CREATE TRIGGER locking_delete_2321
	COMPOUND DELETE ON pfnd0oaroperation FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2321();

DROP TRIGGER IF EXISTS locking_delete_2322 ON pfnd0oaroperationgroup CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2322() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0OAROPERATIONGROUP%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2322() FROM PUBLIC;

CREATE TRIGGER locking_delete_2322
	COMPOUND DELETE ON pfnd0oaroperationgroup FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2322();

DROP TRIGGER IF EXISTS locking_delete_2323 ON pfnd0oarrule CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2323() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0OARRULE%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2323() FROM PUBLIC;

CREATE TRIGGER locking_delete_2323
	COMPOUND DELETE ON pfnd0oarrule FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2323();

DROP TRIGGER IF EXISTS locking_delete_2357 ON pfnd0consentrecord CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2357() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0CONSENTRECORD%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2357() FROM PUBLIC;

CREATE TRIGGER locking_delete_2357
	COMPOUND DELETE ON pfnd0consentrecord FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2357();

DROP TRIGGER IF EXISTS locking_delete_2359 ON pfnd0oarophistory CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2359() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0OAROPHISTORY%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2359() FROM PUBLIC;

CREATE TRIGGER locking_delete_2359
	COMPOUND DELETE ON pfnd0oarophistory FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2359();

DROP TRIGGER IF EXISTS locking_delete_2362 ON pmci0pmimetadata CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2362() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PMCI0PMIMETADATA%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2362() FROM PUBLIC;

CREATE TRIGGER locking_delete_2362
	COMPOUND DELETE ON pmci0pmimetadata FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2362();

DROP TRIGGER IF EXISTS locking_delete_2363 ON pmci0pmicharacteristic CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_2363() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PMCI0PMICHARACTERISTIC%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_2363() FROM PUBLIC;

CREATE TRIGGER locking_delete_2363
	COMPOUND DELETE ON pmci0pmicharacteristic FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_2363();

DROP TRIGGER IF EXISTS locking_delete_530 ON pfnd0auditlink CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_530() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0AUDITLINK%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_530() FROM PUBLIC;

CREATE TRIGGER locking_delete_530
	COMPOUND DELETE ON pfnd0auditlink FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_locking_delete_530();

DROP TRIGGER IF EXISTS locking_delete_570 ON pfnd0tcifeventstore CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locking_delete_570() RETURNS trigger AS $BODY$
compound trigger
   type typ is table of PFND0TCIFEVENTSTORE%rowtype index by integer;
   recs typ;
   v_index                  SIMPLE_INTEGER       := 0;
   PROCEDURE deleteLocks
   AS
   v_deletes       CONSTANT SIMPLE_INTEGER := recs.count();
   BEGIN
   FORALL v_count IN 1..v_deletes
   DELETE FROM POM_LOCK_KEYS WHERE puid = recs[v_count].puid AND NOT EXISTS ( SELECT 1 FROM PPOM_STUB ps WHERE ps.pobject_uid = POM_LOCK_KEYS.puid );
   recs.delete();
   v_index := 0;
   END;
   after each row is
   BEGIN
   v_index := v_index + 1;
   recs[v_index].puid := OLD.puid;
   end after each row;
   AFTER STATEMENT IS
   BEGIN
   deleteLocks();
   END AFTER STATEMENT;
   RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_locking_delete_570() FROM PUBLIC;
